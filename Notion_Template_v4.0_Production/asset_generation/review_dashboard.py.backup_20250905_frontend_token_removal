#!/usr/bin/env python3
"""
Human Review Dashboard for Estate Planning Concierge v4.0
Interactive web interface for reviewing and selecting competitive prompts
"""

import os
import json
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
import logging
from functools import wraps
import secrets
import hashlib
import time

# Web framework imports
try:
    from flask import Flask, render_template, request, jsonify, send_from_directory, make_response
    from flask_cors import CORS
    from flask_limiter import Limiter
    from flask_limiter.util import get_remote_address
    from flask_socketio import SocketIO, emit
    FLASK_AVAILABLE = True
    SOCKETIO_AVAILABLE = True
except ImportError as e:
    FLASK_AVAILABLE = False
    SOCKETIO_AVAILABLE = False
    print(f"Flask dependencies not available: {e}")
    print("Install with: pip install flask flask-cors Flask-Limiter flask-socketio")

# Our modules
from utils.sync_database_manager import SyncAssetDatabase
from utils.session_manager import SessionManager
# from services.prompt_competition_service import PromptCompetitionService  # TODO: Fix import issues
from quality_scorer import QualityScorer, CompetitiveEvaluation

# Security configuration
REVIEW_API_TOKEN = os.getenv('REVIEW_API_TOKEN', 'estate-planning-review-2024')

# Initialize SQLite-based session manager
session_manager = SessionManager(
    db_path="review_sessions.db",
    session_lifetime=3600  # 1 hour session lifetime
)

def token_required(f):
    """Decorator to require authentication token for sensitive endpoints"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        token = request.headers.get('X-API-TOKEN') or request.form.get('api_token') or request.args.get('api_token')
        if token != REVIEW_API_TOKEN:
            return jsonify({
                'success': False, 
                'error': 'Authentication required. Set X-API-TOKEN header or api_token parameter.',
                'code': 'AUTH_REQUIRED'
            }), 401
        return f(*args, **kwargs)
    return decorated_function

def csrf_required(f):
    """Decorator to require CSRF token for state-changing operations"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Skip CSRF for GET requests
        if request.method == 'GET':
            return f(*args, **kwargs)
        
        session_id = request.headers.get('X-Session-ID') or request.form.get('session_id')
        csrf_token = request.headers.get('X-CSRF-Token') or request.form.get('csrf_token')
        
        if not session_id or not csrf_token:
            return jsonify({
                'success': False,
                'error': 'CSRF token required. Include X-CSRF-Token header and X-Session-ID.',
                'code': 'CSRF_REQUIRED'
            }), 403
        
        # Get client IP for logging
        client_ip = request.remote_addr or get_remote_address()
        
        if not session_manager.validate_session(session_id, csrf_token, client_ip):
            return jsonify({
                'success': False,
                'error': 'Invalid or expired CSRF token.',
                'code': 'CSRF_INVALID'
            }), 403
        
        return f(*args, **kwargs)
    return decorated_function

def validate_json(required_fields=None, optional_fields=None, max_lengths=None):
    """Decorator to validate JSON input for API endpoints"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # Check Content-Type
            if request.content_type and 'application/json' not in request.content_type:
                return jsonify({
                    'success': False,
                    'error': 'Content-Type must be application/json',
                    'code': 'INVALID_CONTENT_TYPE'
                }), 400
            
            # Parse JSON
            try:
                data = request.get_json(force=True)
                if data is None:
                    data = {}
            except Exception as e:
                return jsonify({
                    'success': False,
                    'error': f'Invalid JSON: {str(e)}',
                    'code': 'INVALID_JSON'
                }), 400
            
            # Validate required fields
            if required_fields:
                missing_fields = [field for field in required_fields if field not in data]
                if missing_fields:
                    return jsonify({
                        'success': False,
                        'error': f'Missing required fields: {missing_fields}',
                        'code': 'MISSING_FIELDS'
                    }), 400
            
            # Validate field types and lengths
            if max_lengths:
                for field, max_len in max_lengths.items():
                    if field in data and isinstance(data[field], str) and len(data[field]) > max_len:
                        return jsonify({
                            'success': False,
                            'error': f'Field "{field}" exceeds maximum length of {max_len}',
                            'code': 'FIELD_TOO_LONG'
                        }), 400
            
            # Filter out unexpected fields
            all_allowed_fields = set()
            if required_fields:
                all_allowed_fields.update(required_fields)
            if optional_fields:
                all_allowed_fields.update(optional_fields)
            
            if all_allowed_fields:
                filtered_data = {k: v for k, v in data.items() if k in all_allowed_fields}
            else:
                filtered_data = data
            
            # Add validated data to kwargs
            kwargs['validated_data'] = filtered_data
            return f(*args, **kwargs)
        return decorated_function
    return decorator

@dataclass
class ReviewSession:
    """Represents a human review session"""
    session_id: str
    reviewer_name: str
    start_time: str
    pages_reviewed: int
    decisions_made: int
    quality_feedback: List[Dict[str, Any]]
    session_notes: str
    completion_status: str  # 'active', 'paused', 'completed'

@dataclass 
class HumanDecision:
    """Represents a human decision on prompt selection"""
    page_title: str
    page_category: str
    asset_type: str
    selected_prompt_id: str
    selected_model: str
    decision_reasoning: str
    quality_override: Optional[float] = None
    custom_modifications: Optional[str] = None
    decision_timestamp: str = None
    
    def __post_init__(self):
        if self.decision_timestamp is None:
            self.decision_timestamp = datetime.now().isoformat()

class ReviewDashboard:
    """Web-based human review dashboard for prompt selection"""
    
    def __init__(self, db_path: str = "estate_planning_assets.db", port: int = 4500):
        """Initialize the review dashboard"""
        if not FLASK_AVAILABLE:
            raise ImportError("Flask is required. Install with: pip install flask flask-cors flask-socketio")
            
        self.port = port
        self.app = Flask(__name__, template_folder='templates', static_folder='static')
        CORS(self.app)
        
        # Initialize SocketIO for real-time updates
        if SOCKETIO_AVAILABLE:
            self.socketio = SocketIO(self.app, cors_allowed_origins="*", async_mode='threading')
            self._setup_socketio_handlers()
        else:
            self.socketio = None
            
        # Initialize rate limiter (using memory storage for local deployment)
        self.limiter = Limiter(
            app=self.app,
            key_func=get_remote_address,
            default_limits=["1000 per hour", "100 per minute"],
            storage_uri="memory://"  # Using memory for local laptop deployment
        )
        
        # Initialize database with connection pooling (synchronous)
        self.db = SyncAssetDatabase(db_path, pool_size=10)
        # Note: prompt_service and quality_scorer may need sync versions too
        # For now, we'll focus on the main database operations
        self.quality_scorer = QualityScorer()
        
        self.logger = self._setup_logger()
        
        # Session management
        self.current_session: Optional[ReviewSession] = None
        
        # Initialize generation manager
        from generation_manager import GenerationManager
        self.generation_manager = GenerationManager(db_path=db_path)
        
        # Register callbacks for real-time updates
        self.generation_manager.register_progress_callback(self._on_generation_progress)
        self.generation_manager.register_status_callback(self._on_generation_status_change)
        
        # Setup routes
        self._setup_routes()
        self._create_templates()
        
    def _setup_logger(self) -> logging.Logger:
        """Set up logging for the dashboard"""
        logger = logging.getLogger('ReviewDashboard')
        logger.setLevel(logging.INFO)
        
        # Console handler
        ch = logging.StreamHandler()
        ch.setLevel(logging.INFO)
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        ch.setFormatter(formatter)
        logger.addHandler(ch)
        
        # File handler
        fh = logging.FileHandler('review_dashboard.log')
        fh.setLevel(logging.DEBUG)
        fh.setFormatter(formatter)
        logger.addHandler(fh)
        
        return logger
    
    def _setup_routes(self):
        """Setup Flask routes for the dashboard"""
        
        @self.app.route('/static/<path:filename>')
        def static_files(filename):
            """Serve static files (CSS, JS)"""
            return send_from_directory('static', filename)

        @self.app.route('/')
        def index():
            """Main dashboard page"""
            try:
                async def _get_stats():
                    await self.db.init_database()
                    async with self.db.get_connection() as conn:
                        cursor = await conn.execute("SELECT COUNT(*) as total FROM prompt_competitions WHERE competition_status = 'evaluated'")
                        total_row = await cursor.fetchone()
                        cursor = await conn.execute("SELECT COUNT(*) as decided FROM prompt_competitions WHERE competition_status = 'decided'")
                        decided_row = await cursor.fetchone()
                        return total_row['total'] if total_row else 0, decided_row['decided'] if decided_row else 0
                
                # Run the async operation
                total_evaluations, decisions_made = asyncio.run(_get_stats())
            except:
                total_evaluations, decisions_made = 0, 0
            
            # Create response with security headers
            response = make_response(render_template('dashboard.html', 
                                                   session=self.current_session,
                                                   total_evaluations=total_evaluations,
                                                   decisions_made=decisions_made))
            
            # Content Security Policy - Strict mode (no unsafe-inline)
            response.headers['Content-Security-Policy'] = (
                "default-src 'self'; "
                "script-src 'self' https://cdn.jsdelivr.net/npm/dompurify@3.0.5/; "
                "style-src 'self'; "  # Removed 'unsafe-inline' - all styles now external
                "img-src 'self' data:; "
                "connect-src 'self'; "
                "font-src 'self'; "
                "object-src 'none'; "
                "media-src 'self'; "
                "frame-src 'none';"
            )
            
            # Additional security headers
            response.headers['X-Content-Type-Options'] = 'nosniff'
            response.headers['X-Frame-Options'] = 'DENY'
            response.headers['X-XSS-Protection'] = '1; mode=block'
            response.headers['Referrer-Policy'] = 'strict-origin-when-cross-origin'
            
            return response
        
        @self.app.route('/enhanced')
        def enhanced_dashboard():
            """Enhanced dashboard with full visibility features"""
            template_path = Path('templates/dashboard_enhanced.html')
            
            if template_path.exists():
                return render_template('dashboard_enhanced.html')
            else:
                # Fall back to regular dashboard with a message
                from flask import redirect, flash
                return redirect('/')
        
        @self.app.route('/api/get-csrf-token', methods=['POST'])
        @self.limiter.limit("5 per minute")
        @token_required
        def get_csrf_token():
            """Get a CSRF token for the session"""
            # Get client info for session tracking
            client_ip = request.remote_addr or get_remote_address()
            user_agent = request.headers.get('User-Agent', 'Unknown')
            
            # Create session with SQLite backend
            session_data = session_manager.create_session(
                user_data={'api_token_validated': True},
                ip_address=client_ip,
                user_agent=user_agent
            )
            
            return jsonify({
                'success': True,
                'session_id': session_data['session_id'],
                'csrf_token': session_data['csrf_token'],
                'expires_at': session_data['expires_at']
            })
        
        @self.app.route('/api/start-session', methods=['POST'])
        @self.limiter.limit("5 per minute")
        @token_required
        @csrf_required
        @validate_json(optional_fields=['reviewer_name'], max_lengths={'reviewer_name': 100})
        def start_session(validated_data):
            """Start a new review session"""
            reviewer_name = validated_data.get('reviewer_name', 'Anonymous')
            
            # Additional validation
            if reviewer_name and not reviewer_name.strip():
                reviewer_name = 'Anonymous'
            
            self.current_session = ReviewSession(
                session_id=f"review_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                reviewer_name=reviewer_name,
                start_time=datetime.now().isoformat(),
                pages_reviewed=0,
                decisions_made=0,
                quality_feedback=[],
                session_notes="",
                completion_status='active'
            )
            
            self.logger.info(f"Started review session: {self.current_session.session_id}")
            return jsonify({'success': True, 'session': asdict(self.current_session)})
        
        @self.app.route('/api/load-evaluations', methods=['POST'])
        @self.limiter.limit("10 per minute")
        @token_required
        @csrf_required
        @validate_json(optional_fields=[])
        def load_evaluations(validated_data):
            """Load evaluated competitions from database for review"""
            try:
                # Use synchronous database operations
                competitions = self.db.get_competitions(status='evaluated')
                
                return jsonify({
                    'success': True,
                    'competitions_loaded': len(competitions),
                    'message': f'Loaded {len(competitions)} evaluated competitions for review',
                    'competitions': [dict(comp) for comp in competitions]
                })
                    
            except Exception as e:
                self.logger.error(f"Failed to load evaluations from database: {e}")
                return jsonify({'success': False, 'error': str(e)}), 500
        
        @self.app.route('/api/get-competition/<int:competition_id>')
        def get_competition(competition_id):
            """Get specific competition details for review"""
            # Validate competition_id parameter
            if competition_id <= 0:
                return jsonify({
                    'success': False,
                    'error': 'competition_id must be a positive integer',
                    'code': 'INVALID_COMPETITION_ID'
                }), 400
            
            try:
                # Use synchronous database operations
                result = self.db.get_competition_with_evaluations(competition_id)
                
                if not result:
                    return jsonify({'success': False, 'error': 'Competition not found'}), 404
                
                competition = result['competition']
                evaluations = result['evaluations']
                
                # Convert to dict for JSON serialization
                eval_data = {
                    'competition_id': competition_id,
                    'page_title': f"{competition['category']} {competition['index_in_category']}",
                    'page_category': competition['category'],
                    'asset_type': competition['asset_type'],
                    'prompts': [
                        {
                            'id': prompt['id'],
                            'text': prompt['prompt_text'],
                            'model_source': prompt['model_source'],
                            'metadata': json.loads(prompt['metadata']) if prompt['metadata'] else {}
                        }
                        for prompt in prompts
                    ],
                    'evaluations': [
                        {
                            'prompt_text': eval_row['prompt_text'],
                            'model_source': eval_row['model_source'],
                            'overall_score': eval_row['overall_score'],
                            'weighted_score': eval_row['weighted_score'],
                            'individual_scores': json.loads(eval_row['individual_scores']) if eval_row['individual_scores'] else [],
                            'is_winner': eval_row['is_winner']
                        }
                        for eval_row in evaluations
                    ],
                    'winner': next((
                        {
                            'model_source': eval_row['model_source'],
                            'weighted_score': eval_row['weighted_score']
                        }
                        for eval_row in evaluations if eval_row['is_winner']
                    ), None)
                }
                
                return jsonify({'success': True, 'competition': eval_data})
                
            except Exception as e:
                self.logger.error(f"Failed to get competition {competition_id}: {e}")
                return jsonify({'success': False, 'error': str(e)}), 500
        
        @self.app.route('/api/make-decision', methods=['POST'])
        @self.limiter.limit("20 per minute")  # Rate limit decision making
        @token_required
        @csrf_required
        @validate_json(
            required_fields=['competition_id', 'selected_prompt_text', 'selected_model'],
            optional_fields=['reasoning', 'quality_override', 'custom_modifications'],
            max_lengths={
                'selected_prompt_text': 10000,
                'selected_model': 100,
                'reasoning': 2000,
                'custom_modifications': 2000
            }
        )
        def make_decision(validated_data):
            """Record human decision on prompt selection"""
            try:
                # Additional validation
                competition_id = validated_data['competition_id']
                if not isinstance(competition_id, int) or competition_id <= 0:
                    return jsonify({
                        'success': False,
                        'error': 'competition_id must be a positive integer',
                        'code': 'INVALID_COMPETITION_ID'
                    }), 400
                
                reasoning = validated_data.get('reasoning', '')
                if reasoning and len(reasoning.strip()) < 10:
                    return jsonify({
                        'success': False,
                        'error': 'reasoning must be at least 10 characters if provided',
                        'code': 'REASONING_TOO_SHORT'
                    }), 400
                
                # Use synchronous database operations
                decision_data = {
                    'competition_id': validated_data['competition_id'],
                    'selected_prompt_text': validated_data['selected_prompt_text'],
                    'selected_model': validated_data['selected_model'],
                    'decision_reasoning': validated_data.get('reasoning', ''),
                    'quality_override': validated_data.get('quality_override'),
                    'custom_modifications': validated_data.get('custom_modifications'),
                    'reviewer_name': self.current_session.reviewer_name if self.current_session else 'Anonymous'
                }
                
                # Store the decision in database (synchronously)
                decision_id = self.db.store_human_decision(decision_data)
                
                # Update session stats
                if self.current_session:
                    self.current_session.decisions_made += 1
                    self.current_session.pages_reviewed += 1
                
                self.logger.info(f"Decision recorded: Competition {validated_data['competition_id']} -> {validated_data['selected_model']}")
                
                return jsonify({
                    'success': True,
                    'decision_id': decision_id,
                    'competition_id': validated_data['competition_id']
                })
                
            except Exception as e:
                self.logger.error(f"Failed to record decision: {e}")
                return jsonify({'success': False, 'error': str(e)}), 500
        
        @self.app.route('/api/get-progress')
        @self.limiter.limit("30 per minute")  # Rate limit progress checks
        def get_progress():
            """Get current review progress from database"""
            try:
                # Use synchronous database operations
                stats = self.db.get_progress_stats()
                
                progress_data = {
                    'total_evaluations': stats['total_evaluations'],
                    'decisions_made': stats['decisions_made'],
                    'completion_percentage': stats['completion_percentage'],
                    'pending_reviews': stats['pending_reviews'],
                    'session': asdict(self.current_session) if self.current_session else None
                }
                
                return jsonify(progress_data)
                
            except Exception as e:
                self.logger.error(f"Failed to get progress: {e}")
                return jsonify({'success': False, 'error': str(e)}), 500
        
        @self.app.route('/api/export-decisions')
        @self.limiter.limit("5 per minute")  # Rate limit exports  
        @token_required
        def export_decisions():
            """Export all human decisions from database"""
            try:
                # Use synchronous database operations
                decisions = self.db.get_all_decisions()
                
                export_data = {
                    'export_timestamp': datetime.now().isoformat(),
                    'session': asdict(self.current_session) if self.current_session else None,
                    'total_decisions': len(decisions),
                    'decisions': [dict(decision) for decision in decisions],
                    'decision_summary': self._generate_decision_summary_from_db(decisions)
                }
                
                output_file = f"human_decisions_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
                with open(output_file, 'w') as f:
                    json.dump(export_data, f, indent=2)
                
                self.logger.info(f"Exported {len(decisions)} decisions to {output_file}")
                
                return jsonify({
                    'success': True,
                    'file_path': output_file,
                    'total_decisions': len(decisions)
                })
                
            except Exception as e:
                self.logger.error(f"Failed to export decisions: {e}")
                return jsonify({'success': False, 'error': str(e)}), 500
        
        @self.app.route('/api/generate-final-prompts')
        @token_required
        def generate_final_prompts():
            """Generate final prompt selections based on human decisions from database"""
            try:
                # Use synchronous database operations
                decisions = self.db.get_all_decisions()
                final_prompts = {}
                
                for decision in decisions:
                    key = f"{decision['page_category']}_{decision['index_in_category']}_{decision['asset_type']}"
                    final_prompts[key] = {
                        'page_title': f"{decision['page_category']} {decision['index_in_category']}",
                        'page_category': decision['page_category'],
                        'asset_type': decision['asset_type'],
                        'selected_prompt': decision['selected_prompt_text'],
                        'selected_model': decision['selected_model'],
                        'human_reasoning': decision['decision_reasoning'],
                        'custom_modifications': decision['custom_modifications'],
                        'decision_timestamp': decision['decision_timestamp']
                    }
                
                # Save final prompts
                output_file = f"final_selected_prompts_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
                with open(output_file, 'w') as f:
                    json.dump(final_prompts, f, indent=2)
                
                self.logger.info(f"Generated {len(final_prompts)} final prompt selections")
                
                return jsonify({
                    'success': True,
                    'final_prompts_file': output_file,
                    'total_selections': len(final_prompts)
                })
                
            except Exception as e:
                self.logger.error(f"Failed to generate final prompts: {e}")
                return jsonify({'success': False, 'error': str(e)}), 500
        
        # Asset Generation API Endpoints
        @self.app.route('/api/start-sample-generation', methods=['POST'])
        @self.limiter.limit("2 per minute")
        @token_required
        def start_sample_generation():
            """Start sample asset generation (max 10 images for testing)"""
            try:
                data = request.get_json() or {}
                max_images = min(int(data.get('max_images', 5)), 10)  # Cap at 10 for safety
                output_dir = data.get('output_dir')
                
                # Create generation job
                job_id = self.generation_manager.create_sample_job(
                    max_images=max_images,
                    output_dir=output_dir
                )
                
                # Start the job
                success = self.generation_manager.start_job(job_id)
                
                if success:
                    self.logger.info(f"Started sample generation job {job_id} for {max_images} images")
                    return jsonify({
                        'success': True,
                        'job_id': job_id,
                        'job_type': 'sample',
                        'max_images': max_images,
                        'estimated_cost': max_images * 0.04
                    })
                else:
                    return jsonify({
                        'success': False,
                        'error': 'Failed to start generation job'
                    }), 500
                
            except Exception as e:
                self.logger.error(f"Error starting sample generation: {e}")
                return jsonify({'success': False, 'error': str(e)}), 500
        
        @self.app.route('/api/start-full-generation', methods=['POST'])
        @self.limiter.limit("1 per 5 minutes")  # Stricter rate limit for full generation
        @token_required
        def start_full_generation():
            """Start full asset generation (~490 images, ~$20 cost)"""
            try:
                data = request.get_json() or {}
                output_dir = data.get('output_dir')
                
                # Safety confirmation required
                confirmed = data.get('confirmed', False)
                if not confirmed:
                    return jsonify({
                        'success': False,
                        'error': 'Full generation requires explicit confirmation',
                        'requires_confirmation': True,
                        'estimated_images': 490,
                        'estimated_cost': 19.60
                    }), 400
                
                # Create generation job
                job_id = self.generation_manager.create_full_job(output_dir=output_dir)
                
                # Start the job
                success = self.generation_manager.start_job(job_id)
                
                if success:
                    self.logger.info(f"Started FULL generation job {job_id}")
                    return jsonify({
                        'success': True,
                        'job_id': job_id,
                        'job_type': 'full',
                        'estimated_images': 490,
                        'estimated_cost': 19.60
                    })
                else:
                    return jsonify({
                        'success': False,
                        'error': 'Failed to start generation job'
                    }), 500
                
            except Exception as e:
                self.logger.error(f"Error starting full generation: {e}")
                return jsonify({'success': False, 'error': str(e)}), 500
        
        @self.app.route('/api/generation-status/<job_id>')
        @token_required
        def get_generation_status(job_id):
            """Get real-time status of a generation job"""
            try:
                status = self.generation_manager.get_job_status(job_id)
                
                if status:
                    return jsonify({
                        'success': True,
                        'job_status': status
                    })
                else:
                    return jsonify({
                        'success': False,
                        'error': 'Job not found'
                    }), 404
                
            except Exception as e:
                self.logger.error(f"Error getting job status: {e}")
                return jsonify({'success': False, 'error': str(e)}), 500
        
        @self.app.route('/api/cancel-generation/<job_id>', methods=['POST'])
        @token_required
        def cancel_generation(job_id):
            """Cancel a running generation job"""
            try:
                success = self.generation_manager.cancel_job(job_id)
                
                if success:
                    self.logger.info(f"Cancelled generation job {job_id}")
                    return jsonify({
                        'success': True,
                        'message': f'Job {job_id} cancelled successfully'
                    })
                else:
                    return jsonify({
                        'success': False,
                        'error': 'Job not found or cannot be cancelled'
                    }), 400
                
            except Exception as e:
                self.logger.error(f"Error cancelling job: {e}")
                return jsonify({'success': False, 'error': str(e)}), 500
        
        @self.app.route('/api/generation-jobs')
        @token_required
        def get_generation_jobs():
            """Get all active and historical generation jobs"""
            try:
                active_jobs = self.generation_manager.get_active_jobs()
                job_history = self.generation_manager.get_job_history()
                current_job = self.generation_manager.get_current_job()
                
                return jsonify({
                    'success': True,
                    'active_jobs': active_jobs,
                    'job_history': job_history[-10:],  # Last 10 jobs
                    'current_job': current_job
                })
                
            except Exception as e:
                self.logger.error(f"Error getting generation jobs: {e}")
                return jsonify({'success': False, 'error': str(e)}), 500
        
        @self.app.route('/api/generation-logs/<job_id>')
        @token_required
        def get_generation_logs(job_id):
            """Get logs for a specific generation job"""
            try:
                # For now, return basic log info
                # In a full implementation, this would read from log files
                logs = [
                    f"Job {job_id} initialized",
                    f"Starting generation process...",
                    f"Processing images..."
                ]
                
                return jsonify({
                    'success': True,
                    'job_id': job_id,
                    'logs': logs
                })
                
            except Exception as e:
                self.logger.error(f"Error getting generation logs: {e}")
                return jsonify({'success': False, 'error': str(e)}), 500
        
        @self.app.route('/edit-master-prompt')
        def edit_master_prompt():
            """Display the master prompt editor page with support for multiple prompt types"""
            try:
                # Get prompt type from query parameter (default, icons, covers)
                prompt_type = request.args.get('type', 'default')
                
                # Map prompt types to file names
                prompt_files = {
                    'default': 'master_prompt.txt',
                    'icons': 'master_prompt_icons.txt',
                    'covers': 'master_prompt_covers.txt'
                }
                
                # Get the appropriate file
                prompt_file = prompt_files.get(prompt_type, 'master_prompt.txt')
                master_prompt_path = Path(__file__).parent / 'meta_prompts' / prompt_file
                
                # Read current master prompt
                if master_prompt_path.exists():
                    with open(master_prompt_path, 'r', encoding='utf-8') as f:
                        current_prompt = f.read()
                else:
                    current_prompt = f"# {prompt_file} not found. Please create one."
                
                # Get character count and last modified time
                char_count = len(current_prompt)
                last_modified = datetime.fromtimestamp(
                    master_prompt_path.stat().st_mtime
                ).strftime('%Y-%m-%d %H:%M:%S') if master_prompt_path.exists() else 'Never'
                
                # Get all available prompts for tabs
                available_prompts = []
                for ptype, pfile in prompt_files.items():
                    ppath = Path(__file__).parent / 'meta_prompts' / pfile
                    available_prompts.append({
                        'type': ptype,
                        'file': pfile,
                        'exists': ppath.exists(),
                        'active': ptype == prompt_type
                    })
                
                return render_template('master_prompt_editor.html',
                                     current_prompt=current_prompt,
                                     char_count=char_count,
                                     last_modified=last_modified,
                                     prompt_type=prompt_type,
                                     prompt_file=prompt_file,
                                     available_prompts=available_prompts)
                                     
            except Exception as e:
                self.logger.error(f"Error loading master prompt editor: {e}")
                return render_template('error.html', error=str(e)), 500
        
        @self.app.route('/api/get-master-prompt', methods=['GET'])
        def get_master_prompt():
            """Get the current master prompt content for a specific type"""
            try:
                # Get prompt type from query parameter
                prompt_type = request.args.get('type', 'default')
                
                # Map prompt types to file names
                prompt_files = {
                    'default': 'master_prompt.txt',
                    'icons': 'master_prompt_icons.txt',
                    'covers': 'master_prompt_covers.txt'
                }
                
                prompt_file = prompt_files.get(prompt_type, 'master_prompt.txt')
                master_prompt_path = Path(__file__).parent / 'meta_prompts' / prompt_file
                
                if master_prompt_path.exists():
                    with open(master_prompt_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    return jsonify({
                        'success': True,
                        'content': content,
                        'char_count': len(content),
                        'prompt_type': prompt_type,
                        'prompt_file': prompt_file,
                        'last_modified': datetime.fromtimestamp(
                            master_prompt_path.stat().st_mtime
                        ).isoformat()
                    })
                else:
                    return jsonify({
                        'success': False,
                        'error': f'{prompt_file} not found',
                        'prompt_type': prompt_type
                    }), 404
                    
            except Exception as e:
                self.logger.error(f"Error getting master prompt: {e}")
                return jsonify({'success': False, 'error': str(e)}), 500
        
        @self.app.route('/api/save-master-prompt', methods=['POST'])
        @csrf_required
        @token_required
        @validate_json(required_fields=['content'], max_lengths={'content': 10000})
        def save_master_prompt(validated_data=None):
            """Save the updated master prompt for a specific type"""
            try:
                content = validated_data['content']
                prompt_type = validated_data.get('prompt_type', 'default')
                
                # Validate content is not empty
                if not content.strip():
                    return jsonify({
                        'success': False,
                        'error': 'Master prompt cannot be empty'
                    }), 400
                
                # Map prompt types to file names
                prompt_files = {
                    'default': 'master_prompt.txt',
                    'icons': 'master_prompt_icons.txt',
                    'covers': 'master_prompt_covers.txt'
                }
                
                prompt_file = prompt_files.get(prompt_type, 'master_prompt.txt')
                master_prompt_path = Path(__file__).parent / 'meta_prompts' / prompt_file
                
                # Create backup of current prompt
                if master_prompt_path.exists():
                    backup_path = master_prompt_path.with_suffix('.txt.backup')
                    with open(master_prompt_path, 'r', encoding='utf-8') as f:
                        backup_content = f.read()
                    with open(backup_path, 'w', encoding='utf-8') as f:
                        f.write(backup_content)
                
                # Save new prompt
                master_prompt_path.parent.mkdir(parents=True, exist_ok=True)
                with open(master_prompt_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                self.logger.info(f"Master prompt ({prompt_type}) updated - {len(content)} characters")
                
                return jsonify({
                    'success': True,
                    'message': f'Master prompt ({prompt_type}) saved successfully',
                    'char_count': len(content),
                    'prompt_type': prompt_type,
                    'prompt_file': prompt_file,
                    'backup_created': True
                })
                
            except Exception as e:
                self.logger.error(f"Error saving master prompt: {e}")
                return jsonify({'success': False, 'error': str(e)}), 500
        
        @self.app.route('/api/start-generation', methods=['POST'])
        @csrf_required
        @token_required
        @validate_json(
            required_fields=['mode'],
            optional_fields=['test_pages'],
            max_lengths={'mode': 50}
        )
        def start_generation(validated_data=None):
            """Start the asset generation process from web UI"""
            try:
                import subprocess
                import threading
                
                mode = validated_data.get('mode', 'sample')
                test_pages = validated_data.get('test_pages', 3)
                
                # Validate mode
                if mode not in ['sample', 'production']:
                    return jsonify({
                        'success': False,
                        'error': 'Invalid mode. Must be "sample" or "production"'
                    }), 400
                
                # Check if generation is already running
                if hasattr(self, 'generation_process') and self.generation_process and self.generation_process.poll() is None:
                    return jsonify({
                        'success': False,
                        'error': 'Generation already in progress'
                    }), 400
                
                # Build command
                cmd = ['python3', 'asset_generator.py']
                if mode == 'sample':
                    cmd.extend(['--test-pages', str(test_pages)])
                else:
                    cmd.append('--mass-production')
                
                # Start generation in subprocess
                def run_generation():
                    try:
                        self.generation_process = subprocess.Popen(
                            cmd,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            text=True,
                            cwd=Path(__file__).parent
                        )
                        
                        # Stream output (this could be enhanced with WebSocket)
                        for line in iter(self.generation_process.stdout.readline, ''):
                            if line:
                                self.logger.info(f"Generation: {line.strip()}")
                        
                        self.generation_process.wait()
                        
                    except Exception as e:
                        self.logger.error(f"Generation process error: {e}")
                
                # Start in background thread
                generation_thread = threading.Thread(target=run_generation)
                generation_thread.daemon = True
                generation_thread.start()
                
                return jsonify({
                    'success': True,
                    'message': f'Started {mode} generation',
                    'mode': mode,
                    'test_pages': test_pages if mode == 'sample' else None
                })
                
            except Exception as e:
                self.logger.error(f"Error starting generation: {e}")
                return jsonify({'success': False, 'error': str(e)}), 500
    
    def _setup_socketio_handlers(self):
        """Setup WebSocket event handlers"""
        if not self.socketio:
            return
            
        @self.socketio.on('connect')
        def handle_connect():
            """Handle client connection"""
            self.logger.info(f"Client connected: {request.sid}")
            emit('connected', {'message': 'Connected to generation status stream'})
        
        @self.socketio.on('disconnect')
        def handle_disconnect():
            """Handle client disconnection"""
            self.logger.info(f"Client disconnected: {request.sid}")
        
        @self.socketio.on('request_status')
        def handle_status_request():
            """Handle status request from client"""
            if hasattr(self, 'generation_status'):
                emit('status_update', self.generation_status)
            else:
                emit('status_update', {'phase': 'idle', 'progress': 0})
        
        @self.socketio.on('pause_generation')
        def handle_pause():
            """Handle pause request from client"""
            from websocket_broadcaster import get_broadcaster
            broadcaster = get_broadcaster()
            broadcaster.handle_pause()
        
        @self.socketio.on('resume_generation')
        def handle_resume():
            """Handle resume request from client"""
            from websocket_broadcaster import get_broadcaster
            broadcaster = get_broadcaster()
            broadcaster.handle_resume()
        
        @self.socketio.on('abort_generation')
        def handle_abort():
            """Handle abort request from client"""
            from websocket_broadcaster import get_broadcaster
            broadcaster = get_broadcaster()
            self.logger.warning("Generation aborted by user")
            emit('generation_aborted', {'reason': 'User requested abort'})
        
        @self.socketio.on('skip_current')
        def handle_skip():
            """Handle skip current item request"""
            emit('item_skipped', {'timestamp': datetime.now().isoformat()})
        
        @self.socketio.on('update_speed')
        def handle_speed_update(data):
            """Handle speed update request"""
            speed = data.get('speed', 'normal')
            emit('speed_changed', {'speed': speed})
        
        @self.socketio.on('set_mode')
        def handle_mode_change(data):
            """Handle dry-run mode toggle"""
            from websocket_broadcaster import get_broadcaster
            broadcaster = get_broadcaster()
            broadcaster.set_dry_run_mode(data.get('dry_run', False))
        
        @self.socketio.on('approve_prompts')
        def handle_prompt_approval(data):
            """Handle prompt approval from client"""
            prompts = data.get('prompts', [])
            emit('prompts_approved', {'prompts': prompts, 'count': len(prompts)})
        
        @self.socketio.on('reject_prompts')
        def handle_prompt_rejection():
            """Handle prompt rejection from client"""
            emit('prompts_rejected', {'timestamp': datetime.now().isoformat()})
    
    def broadcast_status(self, event_type: str, data: Dict[str, Any]):
        """Broadcast status updates to all connected clients"""
        if self.socketio:
            self.socketio.emit(event_type, data)
            self.logger.debug(f"Broadcast {event_type}: {data}")
    
    def update_generation_status(self, phase: str, progress: int, **kwargs):
        """Update and broadcast generation status"""
        self.generation_status = {
            'phase': phase,
            'progress': progress,
            'timestamp': datetime.now().isoformat(),
            **kwargs
        }
        self.broadcast_status('generation_status', self.generation_status)
    
    def _generate_decision_summary_from_db(self, decisions: List[Dict]) -> Dict[str, Any]:
        """Generate summary statistics for human decisions from database records"""
        if not decisions:
            return {}
        
        model_preferences = {}
        asset_type_counts = {}
        
        for decision in decisions:
            # Count model preferences
            model = decision['selected_model']
            model_preferences[model] = model_preferences.get(model, 0) + 1
            
            # Count asset types
            asset_type = decision['asset_type']
            asset_type_counts[asset_type] = asset_type_counts.get(asset_type, 0) + 1
        
        return {
            'total_decisions': len(decisions),
            'model_preference_ranking': sorted(model_preferences.items(), key=lambda x: x[1], reverse=True),
            'asset_type_distribution': asset_type_counts,
            'decisions_with_custom_modifications': sum(1 for d in decisions if d.get('custom_modifications')),
            'decisions_with_quality_override': sum(1 for d in decisions if d.get('quality_override')),
            'average_decision_reasoning_length': sum(len(d.get('decision_reasoning', '')) for d in decisions) / len(decisions) if decisions else 0
        }
    
    def _create_templates(self):
        """Ensure template directory exists (templates are now external files)"""
        templates_dir = Path('templates')
        templates_dir.mkdir(exist_ok=True)
        
        # Dashboard template is now an external file at templates/dashboard.html
        self.logger.info("Template directory confirmed")
    
    def _on_generation_progress(self, job_id: str, progress_data: Dict[str, Any]):
        """Handle generation progress updates"""
        self.logger.info(f"Generation progress {job_id}: {progress_data['progress']:.1f}% ({progress_data['completed']}/{progress_data['total']})")
        # Future enhancement: Could implement WebSocket broadcasting here
        # For now, progress is available via the /api/generation-status/<job_id> endpoint
    
    def _on_generation_status_change(self, job_id: str, status):
        """Handle generation status changes"""
        self.logger.info(f"Generation status change {job_id}: {status.value}")
        # Future enhancement: Could implement WebSocket broadcasting for real-time UI updates
        # For now, status changes are available via the polling endpoint

    def run(self, debug: bool = True):
        """Run the dashboard server"""
        # Setup periodic session cleanup (every 5 minutes)
        import threading
        
        def cleanup_sessions():
            while True:
                time.sleep(300)  # 5 minutes
                try:
                    expired = session_manager.cleanup_expired_sessions()
                    if expired > 0:
                        self.logger.info(f"Cleaned up {expired} expired sessions")
                except Exception as e:
                    self.logger.error(f"Session cleanup error: {e}")
        
        cleanup_thread = threading.Thread(target=cleanup_sessions, daemon=True)
        cleanup_thread.start()
        
        self.logger.info(f"Starting Review Dashboard on http://localhost:{self.port}")
        print(f"\n🌐 Estate Planning Concierge v4.0 - Review Dashboard")
        print(f"📊 Open http://localhost:{self.port} to start reviewing prompts")
        print(f"🎯 Use this interface to review AI-generated prompts and make final selections")
        print(f"🔐 Authentication Token: {REVIEW_API_TOKEN}")
        print(f"   Set REVIEW_API_TOKEN environment variable to customize")
        
        # Initialize database before starting server
        async def _init_db():
            await self.db.init_database()
            self.logger.info("Database initialized successfully")
        
        try:
            asyncio.run(_init_db())
        except Exception as e:
            self.logger.error(f"Database initialization failed: {e}")
            print(f"Warning: Database initialization failed - {e}")
        
        # Start server with SocketIO if available, otherwise regular Flask
        if self.socketio:
            print(f"🔄 WebSocket support enabled for real-time updates")
            self.socketio.run(self.app, host='0.0.0.0', port=self.port, debug=debug, allow_unsafe_werkzeug=True)
        else:
            self.app.run(host='0.0.0.0', port=self.port, debug=debug)


def create_dashboard_server(port: int = 4500):
    """Create and return a dashboard server instance"""
    try:
        dashboard = ReviewDashboard(port=port)
        return dashboard
    except ImportError as e:
        print(f"Cannot create dashboard: {e}")
        print("Install required dependencies: pip install flask flask-cors")
        return None


async def test_review_dashboard():
    """Test the review dashboard with sample data"""
    print("🎛️ Testing Review Dashboard...")
    
    # Create dashboard (but don't run it in test mode)
    dashboard = create_dashboard_server(port=5001)
    
    if dashboard:
        print(f"✅ Review dashboard created successfully!")
        print(f"📱 Dashboard features:")
        print(f"  - Interactive web interface for prompt review")
        print(f"  - Side-by-side prompt comparison")
        print(f"  - Quality score visualization")
        print(f"  - Human decision recording")
        print(f"  - Progress tracking")
        print(f"  - Export capabilities")
        
        print(f"\n🚀 To run the dashboard:")
        print(f"  dashboard = create_dashboard_server()")
        print(f"  dashboard.run()")
        print(f"  # Then open http://localhost:5000")
        
        return True
    else:
        print("❌ Dashboard creation failed")
        return False


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1 and sys.argv[1] == 'test':
        # Run test
        asyncio.run(test_review_dashboard())
    else:
        # Run dashboard server
        dashboard = create_dashboard_server()
        if dashboard:
            dashboard.run()
        else:
            print("Failed to create dashboard. Check dependencies.")